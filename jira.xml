<?xml version="1.0" encoding="utf-8" ?>
<!--
#    \\ SPIKE: Secure your secrets with SPIFFE.
#  \\\\\ Copyright 2024-present SPIKE contributors.
# \\\\\\\ SPDX-License-Identifier: Apache-2.0
-->
<stuff>
<purpose>
- Our goal is to have a minimally delightful product.
- Strive not to add features just for the sake of adding features.
- If there are half-complete features, missing tests, and the like, they should
  be completed before adding more features.
</purpose>
<low-hanging-fruits>
	<issue>
		Keeper and Nexus do not print anything when they start; at least
		printing some name/version etc. would be nice.
	</issue>
	<issue>
		mode for keeperless operation (fore development maybe).
	</issue>
	<issue>
		The paths that we set in get put ...etc should look like a unix path.
		it will require sanitization!
		Check how other secrets stores manage those paths.
	</issue>
	<issue>
		add the new videos to the site.
	</issue>
</low-hanging-fruits>
<reserved>
	<issue>
		Think about DR scenarios.
	</issue>
	<issue>
		Demo about passwordless SPIKE usage.
	</issue>
	<issue>
		* make asking for admin password during initialization optional.
		(i.e. provide a recovery password: this password will be used
		to recover the root key in case of a system crash)
		* ^ this also means that we won't use JWT to authenticate the admin user.
		--
		`spike init` creates an admin token encrypted with the root key; so
		we still need the explicit initialization step.
		but we don't need password.
		---
		I think I have found the best of both worlds:

		During initialization, I'll ask the admin user something like

		[optional]: Provide root key recovery token (pick a strong unique passphrase, minimum 16 characters).
		p: proceed s: skip

		If pressed (s)

		A pasword recovery token is a "last resort" -break-the-glass- system recovery token. If you don't use this, you will have to ensure that you have <implemented these other things so that you are not dead in the water>. See <this link> for details.
		Enter: Confirm, Esc: provide password.

		This way the user will have the freedom to chose a recovery password, or skip that option and rely on an alternate means to recover the root key.

	</issue>
	<issue>
		Create a demo app.
	</issue>
	<issue>
		move the kv store to a `pkg` folder (after Sahin's PR merge).
	</issue>
	<issue>
		workloads should be able to get/set/read secrets.
		there should be path--workload mapping for that.
		maybe use OPA.

		1. create a sample binary that emulates a workload.
		2. it will fetch its secrets from SPIKE Nexus.
		3. it will update some secrets too.

		Keep the policy management simple and/or delegate it to
		a policy engine. Our goal is to keep SPIKE simple, and we
		don't want create a policy engine.

		This will also require a sample workload and an initial SDK.
	</issue>
	<issue>
		make sure that everything sanitizable are properly sanitized.
	</issue>
	<issue>
		- SPIKE Nexus Sanity Tests
		- Ensure SPIKE Nexus caches the root key in memory.
		- Ensure SPIKE Nexus reads from SPIKE keep if it does not have the root key.
		- Ensure SPIKE Nexus saves the encrypted root key to the database.
		- Ensure SPIKE Nexus caches the user's session key.
		- Ensure SPIKE Nexus removes outdated session keys.
		- Ensure SPIKE Nexus does not re-init (without manual intervention) after
		  being initialized.
		- Ensure SPIKE Nexus adheres to the bootstrapping sequence diagram.
		- Ensure SPIKE Nexus backs up the admin token by encrypting it with the root
		key and storing in the database.
		- Ensure SPIKE Nexus stores the initialization tombstone in the database.
	</issue>
	<issue>
		- SPIKE Pilot Sanity Tests
		- Ensure SPIKE Pilot denies any operation if SPIKE Nexus is not initialized.
		- Ensure SPIKE Pilot can warn if SPIKE Nexus is unreachable
		- Ensure SPIKE Pilot does not indefinitely hang up if SPIRE is not there.
		- Ensure SPIKE Pilot can get and set a secret.
		- Ensure SPIKE Pilot can do a force reset.
		- Ensure SPIKE Pilot can recover the root password.
		- Ensure that after `spike init` you have a password-encrypted root key in the db.
		- Ensure that you can recover the password-encrypted root key.
	</issue>
	<issue>
		- SPIKE Keep Sanity Tests
		- Ensure that the root key is stored in SPIKE Keep's memory.
		- Ensure that SPIKE Keep can return the root key back to SPIKE Nexus.
	</issue>
	<issue>
		Create secret metadata API.
	</issue>
	<issue>
		* encrypt the root key with admin password and return it
		as part of the init response.
		* notify admin to save it to a secure place and delete it.
		* tell the admin to save their password to a safe place too.
	</issue>
	<issue>
		Demo: root key recovery.
	</issue>
	<issue>
		func SetAdminCredentials(passwordHash, salt string) {
		adminCredentialsMu.Lock()
		adminCredentials = Credentials{
		PasswordHash: passwordHash,
		Salt:         salt,
		}
		adminCredentialsMu.Unlock()

		// implement me!
		// persist.AsyncPersistAdminCredentials(passwordHash, salt)
		}
	</issue>
	<issue>
		func AdminCredentials() Credentials {
		adminCredentialsMu.RLock()
		creds := adminCredentials
		adminCredentialsMu.RUnlock()

		// implement database lookup.

		return creds

		}
	</issue>
	<issue>
		If there is a backing store, load all secrets from the backing store
		upon crash, which will also populate the key list.
		after recovery, all secrets will be there and the system will be
		operational.
		after recovery admin will lose its session and will need to re-login.
	</issue>
	<issue>
		Test edge cases:
		* call api method w/o token.
		* call api method w/ invalid token.
		* call api method w/o initializing the nexus.
		* call init twice.
		* call login with bad password.
		^ all these cases should return meaningful errors and
		the user should be informed of what went wrong.
	</issue>
	<issue>
		Try SPIKE on a Mac.
	</issue>
	<issue>
		Try SPIKE on an x-86 Linux.
	</issue>
	<issue>
		Secret metadata API.
	</issue>
	<issue>
		these may come from the environment:

		DataDir:         ".data",
		DatabaseFile:    "spike.db",
		JournalMode:     "WAL",
		BusyTimeoutMs:   5000,
		MaxOpenConns:    10,
		MaxIdleConns:    5,
		ConnMaxLifetime: time.Hour,
	</issue>
	<issue>
		double-encryption of nexus-keeper comms (in case mTLS gets compromised, or
		SPIRE is configured to use an upstream authority that is compromised, this
		will provide end-to-end encryption and an additional layer of security over
		the existing PKI)
	</issue>
</reserved>
<immediate-backlog>
	<issue>
		Add recent recordings to the website.
	</issue>
	<issue>
		// check and verify; when the list is empty it should not return an error.
		responseBody := net.MarshalBody(reqres.SecretListResponse{Keys: keys}, w)
		if responseBody == nil {
		return errors.New("failed to marshal response body")
		}
	</issue>
</immediate-backlog>
<runner-up>
	<issue>
		Minimally Delightful Product Requirements:
		- A containerized SPIKE deployment
		- A Kubernetes SPIKE deployment
		- Minimal policy enforcement
		- Minimal integration tests
		- A demo workload that uses SPIKE to test things out as a consumer.
		- A golang SDK (we can start at github/zerotohero-dev/spike-sdk-go
		  and them move it under spiffe once it matures)
	</issue>
	<issue>
		Maybe move the kv store, and the logger to a `pkg` folder instead of
		`internal` because they are reusable as they are in isolation.
	</issue>
	<issue>
		Kubernetification
	</issue>
	<issue>
		v.1.0.0 Requirements:
		- Having S3 as a backing store
	</issue>
	<issue>
		Consider a health check / heartbeat between Nexus and Keeper.
		This can be more frequent than the root key sync interval.
	</issue>
	<issue>
		Unit tests and coverage reports.
		Create a solid integration test before.
	</issue>
	<issue>
		Test automation.
	</issue>
	<issue>
		Assigning secrets to SPIFFE IDs or SPIFFE ID prefixes.
	</issue>
	<issue>
		RW policies for workloads based on path and SPIFFE IDs.
		(or maybe experiment with S3 policies before reinventing a policy engine)
	</issue>
</runner-up>
<backlog>
	<issue>
		rate limiting to api endpoints.
		more string rate limiting for login attempts.
		lockout after a certain number of failed login attempts.
	</issue>
	<issue>
		* super admin can create regular admins and other super admins.
		* super admin can assign backup admins.
		(see drafts.txt for more details)
	</issue>
	<issue>
		By design, we regard memory as the source of truth.
		This means that backing store might miss some secrets.
		Find ways to reduce the likelihood of this happening.
		1. Implement exponential retries.
		2. Implement a health check to ensure backing store is up.
		3. Create background jobs to sync the backing store.
	</issue>
	<issue>
		certain sqlite persistence operations are not implemented yet.
	</issue>
	<issue>
		Test the db backing store.
	</issue>
</backlog>
<future>
	<issue>
		Do some static analysis.
	</issue>
	<to-plan>
		<issue>
			S3 (or compatible) backing store
		</issue>
		<issue>
			File-based backing store
		</issue>
		<issue>
			In memory backing store
		</issue>
		<issue>
			Kubernetes Deployment
		</issue>
	</to-plan>
	<issue>
		Initial super admin can create other admins.
		So that, if an admin leaves, the super admin can delete them.
		or if the password of an admin is compromised, the super admin can
		reset it.
	</issue>
	<issue>
	- Security Measures (SPIKE Nexus)
		- Encrypting the root key with admin password is good
		Consider adding salt to the password encryption
		- Maybe add a key rotation mechanism for the future
	</issue>
	<issue>
	- Error Handling
		- Good use of exponential retries
		- Consider adding specific error types/codes for different failure scenarios
		- Might want to add cleanup steps for partial initialization failures
	</issue>
	<issue>
	Ability to stream logs and audit trails outside of std out.
	</issue>
	<issue>
	Audit logs should write to a separate location.
	</issue>
	<issue>
	Create a dedicated OIDC resource server (that acts like Pilot but exposes a
	restful API for things like CI/CD integration.
	</issue>
	<issue>
	HSM integration (i.e. root key is managed/provided by an HSM, and the key
	ever leaves the trust boundary of the HSM.
	</issue>
	<issue>
	Ability to rotate the root key (automatic via Nexus).
	</issue>
	<issue>
	Ability to rotate the admin token (manual).
	</issue>
	<issue>
	Admin tokens can expire.
	</issue>
	<issue>
	Encourage to create users instead of relying on the system user.
	</issue>
</future>
</stuff>